<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />




<title>Data Analysis Script</title>

<script src="site_libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/lumen.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>
<link href="site_libs/font-awesome-5.1.0/css/all.css" rel="stylesheet" />
<link href="site_libs/font-awesome-5.1.0/css/v4-shims.css" rel="stylesheet" />

<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>



<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>




<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
</style>


<style type="text/css">
/* padding for bootstrap navbar */
body {
  padding-top: 54px;
  padding-bottom: 40px;
}
/* offset scroll position for anchor links (for fixed navbar)  */
.section h1 {
  padding-top: 59px;
  margin-top: -59px;
}
.section h2 {
  padding-top: 59px;
  margin-top: -59px;
}
.section h3 {
  padding-top: 59px;
  margin-top: -59px;
}
.section h4 {
  padding-top: 59px;
  margin-top: -59px;
}
.section h5 {
  padding-top: 59px;
  margin-top: -59px;
}
.section h6 {
  padding-top: 59px;
  margin-top: -59px;
}
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #ffffff;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script>
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.parent().addClass('active');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  background: white;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->




</head>

<body>


<div class="container-fluid main-container">




<div class="navbar navbar-inverse  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html"><a class="navbar-brand" href="file.html">Attempt on lme4</a></a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Scripts
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="lme4.html">Data analysis</a>
    </li>
    <li>
      <a href="ggplot.html">ggplot</a>
    </li>
    <li>
      <a href="rmd.html">Website</a>
    </li>
    <li>
      <a href="diagf.html">Outliers analysis</a>
    </li>
  </ul>
</li>
<li>
  <a href="references.html">References</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="https://github.com/thasyaaryanti/attempt-on-lme4">
    <span class="fa fa-github"></span>
     
  </a>
</li>
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div class="fluid-row" id="header">



<h1 class="title toc-ignore">Data Analysis Script</h1>

</div>


<div id="loading-data" class="section level3">
<h3>Loading data</h3>
<pre class="r"><code>expdata &lt;- read.csv(file = &quot;Data_Experiment1.csv&quot;, head = TRUE, sep = &quot;,&quot;)
glimpse(expdata)</code></pre>
<pre><code>## Rows: 4,880
## Columns: 8
## $ SubjectID    &lt;int&gt; 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,…
## $ Rotation     &lt;int&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,…
## $ TrialCounter &lt;int&gt; 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, …
## $ TrialID      &lt;int&gt; 311, 226, 177, 367, 476, 460, 315, 307, 258, 125, 121, 4…
## $ RT           &lt;dbl&gt; 0.498, 0.690, 0.585, 1.063, 0.716, 0.739, 0.599, 0.462, …
## $ Response     &lt;int&gt; 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1,…
## $ Condition    &lt;fct&gt; stem_priming, suffix_control, nonword, nonword, nonword,…
## $ Accuracy     &lt;int&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,…</code></pre>
<pre class="r"><code>stimuli &lt;- read.csv(file = &quot;StimuliProperties_Experiment1.csv&quot;, head = TRUE, sep = &quot;,&quot;)
glimpse(stimuli)</code></pre>
<pre><code>## Rows: 160
## Columns: 12
## $ TrialID            &lt;int&gt; 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, …
## $ target             &lt;fct&gt; mamam, blazinam, malicam, barabam, borbam, haljam,…
## $ prime              &lt;fct&gt; oknam, drevesam, berilam, jezeram, soncam, mestam,…
## $ primingMorpheme    &lt;fct&gt; suffix, suffix, suffix, suffix, suffix, suffix, su…
## $ relatedness        &lt;fct&gt; rel, rel, rel, rel, rel, rel, rel, rel, rel, rel, …
## $ targetFreq         &lt;dbl&gt; 119.8, 15.2, 15.2, 6.3, 13.3, 3.1, 26.7, 3.0, 59.8…
## $ primeFreq          &lt;dbl&gt; 79.2, 60.1, 1.5, 62.6, 83.1, 1085.9, 14.2, 50.7, 2…
## $ orthOverlap        &lt;dbl&gt; 0.43, 0.30, 0.46, 0.35, 0.39, 0.38, 0.33, 0.50, 0.…
## $ targetLength       &lt;int&gt; 5, 8, 7, 7, 6, 6, 7, 6, 7, 5, 6, 7, 6, 7, 5, 5, 7,…
## $ PrimeLength        &lt;int&gt; 5, 8, 7, 7, 6, 6, 7, 6, 7, 5, 6, 7, 6, 7, 5, 5, 7,…
## $ targetSuffixLength &lt;int&gt; 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,…
## $ primeSuffixLength  &lt;int&gt; 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,…</code></pre>
</div>
<div id="analysis-of-experimental-items" class="section level3">
<h3>Analysis of experimental items</h3>
<div id="mutating-and-formatting-variables" class="section level4">
<h4>Mutating and formatting variables</h4>
<pre class="r"><code>stimuli &lt;- mutate(stimuli,
  condition =
    ifelse(stimuli$primingMorpheme == &#39;suffix&#39; 
           &amp; stimuli$relatedness == &#39;rel&#39;, &quot;suffix_priming&quot;,
           ifelse(stimuli$primingMorpheme == &#39;suffix&#39;
                  &amp; stimuli$relatedness == &#39;cntr&#39;, &quot;suffix_control&quot;,
                  ifelse(stimuli$primingMorpheme == &#39;stem&#39;
                         &amp; stimuli$relatedness == &#39;rel&#39;, &quot;stem_priming&quot;,
                         ifelse(stimuli$primingMorpheme == &#39;stem&#39;
                                &amp; stimuli$relatedness == &#39;cntr&#39;, &quot;stem_control&quot;,
                                &quot;NULL&quot;)))))
stimuli$condition &lt;- factor(stimuli$condition);
stimuli$primeFreq &lt;- as.double(stimuli$primeFreq);
stimuli$primeStemLength &lt;- stimuli$PrimeLength-stimuli$primeSuffixLength;
stimuli$targetStemLength &lt;- stimuli$targetLength-stimuli$targetSuffixLength</code></pre>
<pre class="r"><code>glimpse(stimuli)</code></pre>
<pre><code>## Rows: 160
## Columns: 15
## $ TrialID            &lt;int&gt; 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, …
## $ target             &lt;fct&gt; mamam, blazinam, malicam, barabam, borbam, haljam,…
## $ prime              &lt;fct&gt; oknam, drevesam, berilam, jezeram, soncam, mestam,…
## $ primingMorpheme    &lt;fct&gt; suffix, suffix, suffix, suffix, suffix, suffix, su…
## $ relatedness        &lt;fct&gt; rel, rel, rel, rel, rel, rel, rel, rel, rel, rel, …
## $ targetFreq         &lt;dbl&gt; 119.8, 15.2, 15.2, 6.3, 13.3, 3.1, 26.7, 3.0, 59.8…
## $ primeFreq          &lt;dbl&gt; 79.2, 60.1, 1.5, 62.6, 83.1, 1085.9, 14.2, 50.7, 2…
## $ orthOverlap        &lt;dbl&gt; 0.43, 0.30, 0.46, 0.35, 0.39, 0.38, 0.33, 0.50, 0.…
## $ targetLength       &lt;int&gt; 5, 8, 7, 7, 6, 6, 7, 6, 7, 5, 6, 7, 6, 7, 5, 5, 7,…
## $ PrimeLength        &lt;int&gt; 5, 8, 7, 7, 6, 6, 7, 6, 7, 5, 6, 7, 6, 7, 5, 5, 7,…
## $ targetSuffixLength &lt;int&gt; 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,…
## $ primeSuffixLength  &lt;int&gt; 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,…
## $ condition          &lt;fct&gt; suffix_priming, suffix_priming, suffix_priming, su…
## $ primeStemLength    &lt;int&gt; 3, 6, 5, 5, 4, 4, 5, 4, 5, 3, 4, 5, 4, 5, 3, 3, 5,…
## $ targetStemLength   &lt;int&gt; 3, 6, 5, 5, 4, 4, 5, 4, 5, 3, 4, 5, 4, 5, 3, 3, 5,…</code></pre>
</div>
<div id="calculating-attributes-of-stimuli" class="section level4">
<h4>Calculating attributes of stimuli</h4>
<pre class="r"><code>aggregate(targetStemLength ~ condition, FUN=mean, data=stimuli);</code></pre>
<pre><code>##        condition targetStemLength
## 1   stem_control            4.325
## 2   stem_priming            4.325
## 3 suffix_control            4.325
## 4 suffix_priming            4.325</code></pre>
<pre class="r"><code>aggregate(targetStemLength~ condition, FUN=sd, data = stimuli);</code></pre>
<pre><code>##        condition targetStemLength
## 1   stem_control         1.118321
## 2   stem_priming         1.118321
## 3 suffix_control         1.118321
## 4 suffix_priming         1.118321</code></pre>
<pre class="r"><code>aggregate(primeStemLength ~ condition, FUN=mean, data=stimuli);</code></pre>
<pre><code>##        condition primeStemLength
## 1   stem_control           4.325
## 2   stem_priming           4.325
## 3 suffix_control           4.350
## 4 suffix_priming           4.325</code></pre>
<pre class="r"><code>aggregate(primeStemLength~ condition, FUN=sd, data = stimuli);</code></pre>
<pre><code>##        condition primeStemLength
## 1   stem_control        1.118321
## 2   stem_priming        1.118321
## 3 suffix_control        1.098951
## 4 suffix_priming        1.118321</code></pre>
<pre class="r"><code>aggregate(targetSuffixLength ~ condition, FUN=mean, data=stimuli);</code></pre>
<pre><code>##        condition targetSuffixLength
## 1   stem_control                  2
## 2   stem_priming                  2
## 3 suffix_control                  2
## 4 suffix_priming                  2</code></pre>
<pre class="r"><code>aggregate(targetSuffixLength~ condition, FUN=sd, data = stimuli);</code></pre>
<pre><code>##        condition targetSuffixLength
## 1   stem_control                  0
## 2   stem_priming                  0
## 3 suffix_control                  0
## 4 suffix_priming                  0</code></pre>
<pre class="r"><code>aggregate(primeSuffixLength ~ condition, FUN=mean, data=stimuli);</code></pre>
<pre><code>##        condition primeSuffixLength
## 1   stem_control                 2
## 2   stem_priming                 2
## 3 suffix_control                 2
## 4 suffix_priming                 2</code></pre>
<pre class="r"><code>aggregate(primeSuffixLength~ condition, FUN=sd, data = stimuli);</code></pre>
<pre><code>##        condition primeSuffixLength
## 1   stem_control                 0
## 2   stem_priming                 0
## 3 suffix_control                 0
## 4 suffix_priming                 0</code></pre>
<pre class="r"><code>aggregate(log10(targetFreq) ~ condition, FUN=mean, data=stimuli);</code></pre>
<pre><code>##        condition log10(targetFreq)
## 1   stem_control          1.457591
## 2   stem_priming          1.457591
## 3 suffix_control          1.457591
## 4 suffix_priming          1.457591</code></pre>
<pre class="r"><code>aggregate(log10(targetFreq) ~ condition, FUN=sd, data = stimuli);</code></pre>
<pre><code>##        condition log10(targetFreq)
## 1   stem_control          0.648854
## 2   stem_priming          0.648854
## 3 suffix_control          0.648854
## 4 suffix_priming          0.648854</code></pre>
<pre class="r"><code>aggregate(log10(primeFreq) ~ condition, FUN=mean, data=stimuli);</code></pre>
<pre><code>##        condition log10(primeFreq)
## 1   stem_control        0.9695187
## 2   stem_priming        1.4575912
## 3 suffix_control        1.2968365
## 4 suffix_priming        1.2968365</code></pre>
<pre class="r"><code>aggregate(log10(primeFreq) ~ condition, FUN=sd, data = stimuli);</code></pre>
<pre><code>##        condition log10(primeFreq)
## 1   stem_control        0.8196274
## 2   stem_priming        0.6488540
## 3 suffix_control        0.8059078
## 4 suffix_priming        0.8059078</code></pre>
<pre class="r"><code>aggregate(orthOverlap ~ condition, FUN=mean, data=stimuli);</code></pre>
<pre><code>##        condition orthOverlap
## 1   stem_control     0.26825
## 2   stem_priming     0.62500
## 3 suffix_control     0.13275
## 4 suffix_priming     0.42375</code></pre>
<pre class="r"><code>aggregate(orthOverlap~ condition, FUN=sd, data = stimuli)</code></pre>
<pre><code>##        condition orthOverlap
## 1   stem_control  0.12180033
## 2   stem_priming  0.04602118
## 3 suffix_control  0.08972858
## 4 suffix_priming  0.09040330</code></pre>
</div>
</div>
<div id="analysis-of-data" class="section level3">
<h3>Analysis of data</h3>
<div id="mutating-and-formatting-variables-1" class="section level4">
<h4>Mutating and formatting variables</h4>
<pre class="r"><code>expdata &lt;- mutate(expdata,
  target =
    ifelse(expdata$TrialID&gt;199 &amp; expdata$TrialID&lt;299, 
           (expdata$TrialID&gt;199 &amp; expdata$TrialID&lt;299)-100,
           ifelse(expdata$TrialID&gt;299 &amp; expdata$TrialID&lt;399, 
                  (expdata$TrialID&gt;299 &amp; expdata$TrialID&lt;399)-200,
                  ifelse(expdata$TrialID&gt;399 &amp; expdata$TrialID&lt;499, 
                         (expdata$TrialID&gt;399 &amp; expdata$TrialID&lt;499)-300,
                         expdata$TrialID-100))))

expdata$target &lt;- factor(expdata$target);
expdata$SubjectID &lt;- factor(expdata$SubjectID)

expdata &lt;- mutate(expdata,
  cond =
    ifelse(expdata$Condition == &#39;suffix_priming&#39;, 
           &#39;suffix&#39;,
           ifelse(expdata$Condition == &#39;suffix_control&#39;, 
                  &#39;suffix&#39;,
                  ifelse(expdata$Condition == &#39;nonword&#39;, 
                         NA,
                         ifelse(expdata$Condition == &#39;stem_control&#39;,
                                &#39;stem&#39;,
                                &#39;stem&#39;)))))

expdata &lt;- mutate(expdata,
  relation =
    ifelse(expdata$Condition == &#39;suffix_priming&#39;, 
           &#39;prime&#39;,
           ifelse(expdata$Condition == &#39;suffix_control&#39;, 
                  &#39;control&#39;,
                  ifelse(expdata$Condition == &#39;nonword&#39;, 
                         NA,
                         ifelse(expdata$Condition == &#39;stem_control&#39;,
                                &#39;control&#39;,
                                &#39;prime&#39;)))))

# convert the new variables to factors
expdata$relation &lt;- factor(expdata$relation); 
expdata$cond &lt;- factor(expdata$cond)

expdata &lt;- mutate(expdata,
  category =
    ifelse(expdata$Condition == &#39;nonword&#39;, 
           &#39;nonword&#39;,
           &#39;word&#39;))

expdata$category = factor(expdata$category)</code></pre>
<pre class="r"><code>glimpse(expdata)</code></pre>
<pre><code>## Rows: 4,880
## Columns: 12
## $ SubjectID    &lt;fct&gt; 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,…
## $ Rotation     &lt;int&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,…
## $ TrialCounter &lt;int&gt; 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, …
## $ TrialID      &lt;int&gt; 311, 226, 177, 367, 476, 460, 315, 307, 258, 125, 121, 4…
## $ RT           &lt;dbl&gt; 0.498, 0.690, 0.585, 1.063, 0.716, 0.739, 0.599, 0.462, …
## $ Response     &lt;int&gt; 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1,…
## $ Condition    &lt;fct&gt; stem_priming, suffix_control, nonword, nonword, nonword,…
## $ Accuracy     &lt;int&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,…
## $ target       &lt;fct&gt; -199, -99, 77, -199, -299, -299, -199, -199, -99, 25, 21…
## $ cond         &lt;fct&gt; stem, suffix, NA, NA, NA, NA, stem, stem, NA, suffix, su…
## $ relation     &lt;fct&gt; prime, control, NA, NA, NA, NA, prime, prime, NA, prime,…
## $ category     &lt;fct&gt; word, word, nonword, nonword, nonword, nonword, word, wo…</code></pre>
</div>
<div id="checking-and-handling-outliers" class="section level4">
<h4>Checking and handling outliers</h4>
<p>A <a href="diagf.rmd">separate script</a> was used to graph and identify any outliers present in the data.</p>
<pre class="r"><code>source(&quot;diagf.R&quot;);
diagnostics.f(expdata$RT, expdata$Accuracy, expdata$SubjectID, expdata$target, expdata$category , &quot;outliers&quot;)</code></pre>
<div class="figure">
<img src="outliers.jpg" alt="From the graphs above, we can see several outliers within the subjects and the target words used. As stated in Marjanovic &amp; Crepaldi(2020), subject 13 and target word 39 would be excluded from further analysis. Under the histogram, we can also see some responses with 0.0 response times. These are perhaps trials where no responses were provided, hence these will also be removed." />
<p class="caption">From the graphs above, we can see several outliers within the subjects and the target words used. As stated in Marjanovic &amp; Crepaldi(2020), subject 13 and target word 39 would be excluded from further analysis. Under the histogram, we can also see some responses with 0.0 response times. These are perhaps trials where no responses were provided, hence these will also be removed.</p>
</div>
<pre class="r"><code>expdata_2 &lt;- subset(expdata, Condition != &#39;nonword&#39; &amp; SubjectID != &#39;13&#39; &amp; target != &#39;39&#39; &amp; RT&gt;0);
summary(expdata_2)</code></pre>
<pre><code>##    SubjectID       Rotation      TrialCounter      TrialID     
##  2      :  40   Min.   :1.000   Min.   :11.00   Min.   :101.0  
##  3      :  40   1st Qu.:1.000   1st Qu.:29.00   1st Qu.:201.0  
##  6      :  40   Median :2.000   Median :49.00   Median :301.0  
##  7      :  40   Mean   :2.463   Mean   :49.76   Mean   :271.5  
##  9      :  40   3rd Qu.:3.000   3rd Qu.:70.00   3rd Qu.:401.0  
##  10     :  40   Max.   :4.000   Max.   :90.00   Max.   :440.0  
##  (Other):2140                                                  
##        RT            Response               Condition      Accuracy     
##  Min.   :0.2870   Min.   :0.0000   nonword       :  0   Min.   :0.0000  
##  1st Qu.:0.5730   1st Qu.:1.0000   stem_control  :599   1st Qu.:1.0000  
##  Median :0.6740   Median :1.0000   stem_priming  :600   Median :1.0000  
##  Mean   :0.7297   Mean   :0.9403   suffix_control:599   Mean   :0.9403  
##  3rd Qu.:0.8280   3rd Qu.:1.0000   suffix_priming:582   3rd Qu.:1.0000  
##  Max.   :1.8980   Max.   :1.0000                        Max.   :1.0000  
##                                                                         
##      target        cond         relation       category   
##  -199   :600   stem  :1199   control:1198   nonword:   0  
##  -299   :599   suffix:1181   prime  :1182   word   :2380  
##  -99    :599                                              
##  8      : 16                                              
##  12     : 16                                              
##  16     : 16                                              
##  (Other):534</code></pre>
</div>
<div id="experimental-data-descriptive-statistics" class="section level4">
<h4>Experimental data descriptive statistics</h4>
<p>Before proceeding with <code>lme4</code>, here are the descriptive statistics (mean RT and accuracy) for four of the different conditions.</p>
<pre class="r"><code>expdata_2 &lt;- mutate(expdata_2,
  RTms =
    1000*expdata_2$RT)

aggregate(RTms ~ Condition, FUN=mean, data=expdata_2); </code></pre>
<pre><code>##        Condition     RTms
## 1   stem_control 724.0017
## 2   stem_priming 707.8450
## 3 suffix_control 750.9032
## 4 suffix_priming 736.4313</code></pre>
<pre class="r"><code>aggregate(RTms ~ Condition, FUN=sd, data = expdata_2);</code></pre>
<pre><code>##        Condition     RTms
## 1   stem_control 224.8562
## 2   stem_priming 226.3734
## 3 suffix_control 246.4788
## 4 suffix_priming 232.4626</code></pre>
<pre class="r"><code>aggregate(Accuracy ~ Condition, FUN=mean, data=expdata_2);</code></pre>
<pre><code>##        Condition  Accuracy
## 1   stem_control 0.9432387
## 2   stem_priming 0.9483333
## 3 suffix_control 0.9348915
## 4 suffix_priming 0.9347079</code></pre>
<pre class="r"><code>aggregate(Accuracy ~ Condition, FUN=sd, data=expdata_2);</code></pre>
<pre><code>##        Condition  Accuracy
## 1   stem_control 0.2315793
## 2   stem_priming 0.2215379
## 3 suffix_control 0.2469234
## 4 suffix_priming 0.2472531</code></pre>
</div>
<div id="lme4-trial" class="section level4">
<h4>lme4 trial</h4>
<p>After modifying the dataset, it is time to attempt on <code>lme4</code>. As a first-timer in <code>lme4</code>, it is great that I have the analysis and results from the paper where the data is from, to compare and see whether my analysis is correct.</p>
<div id="trial-1" class="section level5">
<h5>Trial 1</h5>
<p>Before I begin my first <code>lme4</code> attempt, I watched a <a href="https://youtu.be/9BDA5b-gtbc">tutorial</a> on linear mixed effects model and coding the model with the <code>lme4</code> package on R. With the video, I understood that the model is called <em>mixed effects</em> because of the inclusion of <strong>fixed</strong> and <strong>random</strong> effects. Comparing a linear mixed effect model (lme) to ANOVA, fixed effects and random effects in lme can be thought of as the independent variable and error variable in ANOVA respectively.</p>
<p>In my first trial of <code>lme4</code>, I read through the research paper to understand what analysis was done and what was entered into the lme model as fixed and random effects. As stated under the data analysis section, inverse-transformed (i.e., -1000/RT) RT was analysed with relation, condition, and their interaction as fixed effects, with subject and target words as random effects (Marjanovic &amp; Crepaldi, 2020). In terms of covariates, stem frequency was included as a fixed effect.</p>
<p>Thus, I entered those values into three different models (i.e., relation, condition, and relation*condition). Along with that, instead of analysing accuracy of responses like the paper did, I wanted to calculate the error rates and analyse it with <code>glmer</code> instead.</p>
<pre class="r"><code>expdata_2 &lt;- mutate(expdata_2,
  error =
    ifelse(expdata_2$Accuracy == 1, 
           0,
           1))

expdata_2 &lt;- mutate(expdata_2,
  invcrt =
    -1000/expdata_2$RTms)

all &lt;- merge(expdata_2, stimuli, by.x = &#39;TrialID&#39;, by.y = &#39;TrialID&#39;)</code></pre>
<pre class="r"><code>relation_glmer &lt;- glmer(error ~ relation+primeFreq+(1|target.x)+(1|SubjectID), data = all, family = binomial)
condition_glmer &lt;- glmer(error ~ cond+primeFreq+(1|target.x)+(1|SubjectID), data = all, family = binomial)
int_glmer &lt;- glmer(error ~ relation*cond+primeFreq+(1|target.x)+(1|SubjectID), data = all, family = binomial)

relation_lmer &lt;- lmer(invcrt ~ relation+primeFreq+(1|target.x)+(1|SubjectID), data = all)
condition_lmer &lt;- lmer(invcrt ~ cond+primeFreq+(1|target.x)+(1|SubjectID), data = all)
int_lmer &lt;- lmer(error ~ relation*cond+primeFreq+(1|target.x)+(1|SubjectID), data = all)</code></pre>
<pre class="r"><code>summary(int_lmer)</code></pre>
<pre><code>## Linear mixed model fit by REML. t-tests use Satterthwaite&#39;s method [
## lmerModLmerTest]
## Formula: error ~ relation * cond + primeFreq + (1 | target.x) + (1 | SubjectID)
##    Data: all
## 
## REML criterion at convergence: -85.3
## 
## Scaled residuals: 
##     Min      1Q  Median      3Q     Max 
## -0.9437 -0.2958 -0.2133 -0.1364  4.1738 
## 
## Random effects:
##  Groups    Name        Variance Std.Dev.
##  SubjectID (Intercept) 0.001645 0.04056 
##  target.x  (Intercept) 0.001160 0.03406 
##  Residual              0.054138 0.23268 
## Number of obs: 2380, groups:  SubjectID, 60; target.x, 42
## 
## Fixed effects:
##                            Estimate Std. Error         df t value Pr(&gt;|t|)  
## (Intercept)               5.416e-02  3.577e-02  2.383e+00   1.514   0.2495  
## relationprime            -6.660e-03  5.001e-02  2.278e+00  -0.133   0.9049  
## condsuffix                5.485e-03  5.003e-02  2.280e+00   0.110   0.9216  
## primeFreq                 5.964e-05  2.791e-05  2.250e+02   2.136   0.0337 *
## relationprime:condsuffix  6.528e-03  6.225e-02  2.389e+00   0.105   0.9246  
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## Correlation of Fixed Effects:
##             (Intr) rltnpr cndsff prmFrq
## relationprm -0.699                     
## condsuffix  -0.698  0.500              
## primeFreq   -0.034 -0.015 -0.027       
## rltnprm:cnd  0.561 -0.803 -0.803  0.011</code></pre>
<pre class="r"><code>anova(int_lmer)</code></pre>
<pre><code>## Type III Analysis of Variance Table with Satterthwaite&#39;s method
##                 Sum Sq  Mean Sq NumDF   DenDF F value  Pr(&gt;F)  
## relation      0.000644 0.000644     1   2.389  0.0119 0.92161  
## cond          0.004274 0.004274     1   2.392  0.0789 0.80121  
## primeFreq     0.247109 0.247109     1 224.960  4.5644 0.03372 *
## relation:cond 0.000596 0.000596     1   2.389  0.0110 0.92463  
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</code></pre>
<p>From this analysis, my <code>glmer</code> returned a <span style="color: red;">boundary (singular) fit: see ?isSingular</span> error. After googling what it meant, it seems as though singular fit may be because of either collinearity in fixed effects or that a random effect variance is very near zero. Perhaps my idea of analysing error may not be appropriate for this data set? Or perhaps I may be over challenging myself as a first-timer.</p>
<p>Running an anova analysis on the interaction lme model, it automatically runs it with Satterthwaite’s method where degrees of freedom is calculated bassed on Satterthwaite’s approximation. Looking at the analysis, I realise three things. First, my values are so different from what was reported in the paper (shown below). Second, the values reported in the paper may be there in the analysis result, but perhaps I am not reading the analysis right. Lastly, it is also possible that my codes are wrong.</p>
<p>I decided to perform an anova analysis from the lme4 package itself and see how the results differ.</p>
<pre class="r"><code>anova(int_lmer, ddf = &quot;lme4&quot;)</code></pre>
<pre><code>## Analysis of Variance Table
##               npar   Sum Sq  Mean Sq F value
## relation         1 0.000652 0.000652  0.0120
## cond             1 0.008245 0.008245  0.1523
## primeFreq        1 0.246878 0.246878  4.5602
## relation:cond    1 0.000596 0.000596  0.0110</code></pre>
<p>Once again, the results are super different from the ones in the paper.</p>
</div>
<div id="trial-2" class="section level5">
<h5>Trial 2</h5>
<p>In the next trial, I thought perhaps if we entered the covariate in log form and centered according to their respective means and SD it may work. I came to this decision after going through other data uploaded on the Open Science Framework <a href="https://osf.io/">website</a>, and one analysis on psycholinguistics data using <code>lme4</code> entered the covariates in logs form.</p>
<p>At this point, I am only trying the interaction effect and putting the error rates aside for the moment.</p>
<p>Firstly, I tried the log values.</p>
<pre class="r"><code>all2 &lt;- mutate(all,logprfq = log10(primeFreq))

int_lmer_log &lt;- lmer(invcrt ~ relation*cond + logprfq + (1|target.x) + (1|SubjectID), data = all2)
summary(int_lmer_log)</code></pre>
<pre><code>## Linear mixed model fit by REML. t-tests use Satterthwaite&#39;s method [
## lmerModLmerTest]
## Formula: invcrt ~ relation * cond + logprfq + (1 | target.x) + (1 | SubjectID)
##    Data: all2
## 
## REML criterion at convergence: 1258.5
## 
## Scaled residuals: 
##     Min      1Q  Median      3Q     Max 
## -4.9589 -0.6194 -0.0677  0.6346  3.8161 
## 
## Random effects:
##  Groups    Name        Variance Std.Dev.
##  SubjectID (Intercept) 0.07376  0.2716  
##  target.x  (Intercept) 0.01176  0.1085  
##  Residual              0.08833  0.2972  
## Number of obs: 2380, groups:  SubjectID, 60; target.x, 42
## 
## Fixed effects:
##                            Estimate Std. Error         df t value Pr(&gt;|t|)    
## (Intercept)              -1.459e+00  1.150e-01  1.993e+01 -12.687 5.31e-11 ***
## relationprime            -2.632e-02  1.544e-01  1.627e+01  -0.170    0.867    
## condsuffix                5.174e-02  1.544e-01  1.625e+01   0.335    0.742    
## logprfq                  -3.561e-02  9.071e-03  1.644e+03  -3.926 9.00e-05 ***
## relationprime:condsuffix  9.076e-03  1.903e-01  1.639e+01   0.048    0.963    
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## Correlation of Fixed Effects:
##             (Intr) rltnpr cndsff lgprfq
## relationprm -0.669                     
## condsuffix  -0.670  0.500              
## logprfq     -0.077 -0.028 -0.019       
## rltnprm:cnd  0.543 -0.811 -0.811  0.020</code></pre>
<pre class="r"><code>anova(int_lmer_log)</code></pre>
<pre><code>## Type III Analysis of Variance Table with Satterthwaite&#39;s method
##                Sum Sq Mean Sq NumDF   DenDF F value    Pr(&gt;F)    
## relation      0.00463 0.00463     1   16.40  0.0524    0.8218    
## cond          0.03092 0.03092     1   16.38  0.3501    0.5622    
## logprfq       1.36136 1.36136     1 1644.08 15.4118 9.002e-05 ***
## relation:cond 0.00020 0.00020     1   16.39  0.0023    0.9625    
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</code></pre>
<pre class="r"><code>anova(int_lmer_log, ddf = &quot;lme4&quot;)</code></pre>
<pre><code>## Analysis of Variance Table
##               npar  Sum Sq Mean Sq F value
## relation         1 0.00004 0.00004  0.0004
## cond             1 0.03393 0.03393  0.3841
## logprfq          1 1.36260 1.36260 15.4258
## relation:cond    1 0.00020 0.00020  0.0023</code></pre>
<p>Again, neither the relation or condition effects are significant.</p>
<p>Next I tried whether it will work if it is centered according to their respective means (<em>I don’t think it will, but no harm in trying</em>).</p>
<pre class="r"><code>all2 &lt;- mutate(all2, cov = ifelse(all2$Condition == &#39;stem_priming&#39;,
                                      ((all2$logprfq-1.4575912)/0.6488540),
                                      ifelse(all2$Condition == &#39;stem_control&#39;,
                                             ((all2$logprfq-0.9695187)/0.8196274),
                                             ((all2$logprfq-1.2968365)/0.8059078))))

int_lmer_cov &lt;- lmer(invcrt ~ relation*cond + cov + (1|target.x) + (1|SubjectID), data = all2)

summary(int_lmer_cov)</code></pre>
<pre><code>## Linear mixed model fit by REML. t-tests use Satterthwaite&#39;s method [
## lmerModLmerTest]
## Formula: invcrt ~ relation * cond + cov + (1 | target.x) + (1 | SubjectID)
##    Data: all2
## 
## REML criterion at convergence: 1257
## 
## Scaled residuals: 
##     Min      1Q  Median      3Q     Max 
## -4.9600 -0.6230 -0.0649  0.6355  3.8185 
## 
## Random effects:
##  Groups    Name        Variance Std.Dev.
##  SubjectID (Intercept) 0.07375  0.2716  
##  target.x  (Intercept) 0.01182  0.1087  
##  Residual              0.08825  0.2971  
## Number of obs: 2380, groups:  SubjectID, 60; target.x, 42
## 
## Fixed effects:
##                            Estimate Std. Error         df t value Pr(&gt;|t|)    
## (Intercept)              -1.493e+00  1.149e-01  1.984e+01 -12.998 3.66e-11 ***
## relationprime            -4.369e-02  1.547e-01  1.637e+01  -0.282    0.781    
## condsuffix                4.009e-02  1.547e-01  1.637e+01   0.259    0.799    
## cov                      -2.902e-02  6.944e-03  1.753e+03  -4.179 3.07e-05 ***
## relationprime:condsuffix  2.649e-02  1.907e-01  1.650e+01   0.139    0.891    
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## Correlation of Fixed Effects:
##             (Intr) rltnpr cndsff cov   
## relationprm -0.673                     
## condsuffix  -0.673  0.500              
## cov          0.000  0.000  0.000       
## rltnprm:cnd  0.546 -0.811 -0.811 -0.003</code></pre>
<pre class="r"><code>anova(int_lmer_cov)</code></pre>
<pre><code>## Type III Analysis of Variance Table with Satterthwaite&#39;s method
##                Sum Sq Mean Sq NumDF  DenDF F value    Pr(&gt;F)    
## relation      0.00900 0.00900     1   16.5  0.1020    0.7535    
## cond          0.02762 0.02762     1   16.5  0.3129    0.5834    
## cov           1.54129 1.54129     1 1752.6 17.4649 3.071e-05 ***
## relation:cond 0.00170 0.00170     1   16.5  0.0193    0.8912    
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</code></pre>
<pre class="r"><code>anova(int_lmer_cov, ddf = &quot;lme4&quot;)</code></pre>
<pre><code>## Analysis of Variance Table
##               npar  Sum Sq Mean Sq F value
## relation         1 0.00003 0.00003  0.0004
## cond             1 0.03374 0.03374  0.3823
## cov              1 1.54102 1.54102 17.4618
## relation:cond    1 0.00170 0.00170  0.0193</code></pre>
<p>As expected, results still aren’t right.</p>
</div>
<div id="trial-3" class="section level5">
<h5>Trial 3</h5>
<p>In this trial, I checked the <a href="https://osf.io/7t2d3/">original script</a> posted on Open Science Framework and the authors did specify a reference level and create a subset of only data with the correct response. I’ve looked up what <code>relevel</code> does and it seems as if it is ordering the data in terms of the reference level. Not sure how this would make any difference in the analysis, but again, it is worth trying it out.</p>
<pre class="r"><code>true &lt;- subset(all, Accuracy == 1)
true$relation &lt;- relevel(true$relation, &#39;control&#39;);
true$cond &lt;- relevel(true$cond, &#39;stem&#39;)

int_lmer_lvl &lt;- lmer(invcrt ~ relation*cond + primeFreq + (1|target.x) + (1|SubjectID), data = true)

summary(int_lmer_lvl)</code></pre>
<pre><code>## Linear mixed model fit by REML. t-tests use Satterthwaite&#39;s method [
## lmerModLmerTest]
## Formula: invcrt ~ relation * cond + primeFreq + (1 | target.x) + (1 |  
##     SubjectID)
##    Data: true
## 
## REML criterion at convergence: 1007.4
## 
## Scaled residuals: 
##     Min      1Q  Median      3Q     Max 
## -4.5428 -0.6286 -0.0503  0.6284  4.1225 
## 
## Random effects:
##  Groups    Name        Variance Std.Dev.
##  SubjectID (Intercept) 0.074130 0.27227 
##  target.x  (Intercept) 0.007716 0.08784 
##  Residual              0.080927 0.28448 
## Number of obs: 2238, groups:  SubjectID, 60; target.x, 42
## 
## Fixed effects:
##                            Estimate Std. Error         df t value Pr(&gt;|t|)    
## (Intercept)              -1.508e+00  9.539e-02  1.658e+01 -15.808 1.99e-11 ***
## relationprime            -5.713e-02  1.254e-01  1.245e+01  -0.456  0.65646    
## condsuffix                4.350e-02  1.254e-01  1.245e+01   0.347  0.73448    
## primeFreq                 1.079e-04  3.907e-05  6.029e+02   2.762  0.00593 ** 
## relationprime:condsuffix  2.724e-02  1.547e-01  1.260e+01   0.176  0.86302    
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## Correlation of Fixed Effects:
##             (Intr) rltnpr cndsff prmFrq
## relationprm -0.657                     
## condsuffix  -0.657  0.500              
## primeFreq   -0.018 -0.008 -0.014       
## rltnprm:cnd  0.533 -0.811 -0.811  0.007</code></pre>
<pre class="r"><code>anova(int_lmer_lvl)</code></pre>
<pre><code>## Type III Analysis of Variance Table with Satterthwaite&#39;s method
##                Sum Sq Mean Sq NumDF  DenDF F value   Pr(&gt;F)   
## relation      0.02561 0.02561     1  12.60  0.3165 0.583583   
## cond          0.04412 0.04412     1  12.61  0.5452 0.473801   
## primeFreq     0.61714 0.61714     1 602.94  7.6259 0.005929 **
## relation:cond 0.00251 0.00251     1  12.60  0.0310 0.863015   
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</code></pre>
<pre class="r"><code>anova(int_lmer_lvl, ddf = &quot;lme4&quot;)</code></pre>
<pre><code>## Analysis of Variance Table
##               npar  Sum Sq Mean Sq F value
## relation         1 0.00148 0.00148  0.0183
## cond             1 0.06221 0.06221  0.7687
## primeFreq        1 0.61663 0.61663  7.6195
## relation:cond    1 0.00251 0.00251  0.0310</code></pre>
</div>
<div id="trial-4" class="section level5">
<h5>Trial 4</h5>
<p>After hours of reading through forums and papers, I realised that perhaps p-values aren’t as straightforward when analysing with <code>lme4</code>. One way to attain p-values with <code>lme4</code> is through comparing models and paying attention to the Likelihood Ratio Test ( <a href="references.html">Winter, 2015</a> ). With main effects, a null model (i.e., without factors that I am interested in) should be created. In my case, it would be a model with the covariate.</p>
<pre class="r"><code>null &lt;- lmer(invcrt ~ primeFreq + (1|target.x) + (1|SubjectID), data = all, REML = FALSE)</code></pre>
<p>Then, the model with the factor that I am interested in. This time I tried the condtion factor. I did not analyse interaction here because it needs to be compared with a different null, which I did later on.</p>
<pre class="r"><code>cond_lmer &lt;- lmer(invcrt ~ cond+primeFreq+(1|target.x)+(1|SubjectID), data = all, REML = FALSE)</code></pre>
<p>Next, we compare both models using <code>anova</code></p>
<pre class="r"><code>anova(null, cond_lmer)</code></pre>
<pre><code>## Data: all
## Models:
## null: invcrt ~ primeFreq + (1 | target.x) + (1 | SubjectID)
## cond_lmer: invcrt ~ cond + primeFreq + (1 | target.x) + (1 | SubjectID)
##           npar    AIC    BIC  logLik deviance  Chisq Df Pr(&gt;Chisq)
## null         5 1258.4 1287.2 -624.19   1248.4                     
## cond_lmer    6 1259.9 1294.6 -623.96   1247.9 0.4648  1     0.4954</code></pre>
<p>Chi Square p-values are not significant. Next I tried to do the same with the relation main effect.</p>
<pre class="r"><code>relation_lmer &lt;- lmer(invcrt ~ relation+primeFreq+(1|target.x)+(1|SubjectID), data = all, REML = FALSE)
anova(null, cond_lmer)</code></pre>
<p>Both yielded results that were not significant which were significant in the paper. However, before I move on to the next trial, I tried to analyse the interaction to see whether this method could give me similar results as what was reported in the paper.</p>
<p>With comparing interaction, the interaction model should be compared to the model that includes both factors.</p>
<pre class="r"><code>null_int &lt;- lmer(invcrt ~ cond + relation + primeFreq + (1|target.x) + (1|SubjectID), data = all, REML = FALSE)
int_lmer &lt;- lmer(invcrt ~ cond*relation + primeFreq + (1|target.x) + (1|SubjectID), data = all, REML = FALSE)
anova(null_int, int_lmer)</code></pre>
<pre><code>## Data: all
## Models:
## null_int: invcrt ~ cond + relation + primeFreq + (1 | target.x) + (1 | 
## null_int:     SubjectID)
## int_lmer: invcrt ~ cond * relation + primeFreq + (1 | target.x) + (1 | 
## int_lmer:     SubjectID)
##          npar    AIC    BIC  logLik deviance  Chisq Df Pr(&gt;Chisq)
## null_int    7 1261.7 1302.2 -623.86   1247.7                     
## int_lmer    8 1263.7 1309.9 -623.84   1247.7 0.0369  1     0.8476</code></pre>
<p>Results still aren’t right. Along with that, I am pretty unfamiliar with Chi Square Tests as I’ve never done it before. I wasn’t sure what was wrong. Is it because of my <code>lme4</code> codes? Or is it because my data set is wrong entirely. Hence, in the next trial I decided to start afresh and code a new script based on the original script and see if I can get the same results as reported in the paper.</p>
</div>
<div id="trial-5" class="section level5">
<h5>Trial 5</h5>
<pre class="r"><code>#create new environment
stim &lt;- read.csv(file = &quot;StimuliProperties_Experiment1.csv&quot;, head = TRUE, sep = &quot;,&quot;)
summary(stim)</code></pre>
<pre><code>##     TrialID            target        prime     primingMorpheme relatedness
##  Min.   :101.0   akcijam  :  4   abonmov:  2   stem  :80       cntr:80    
##  1st Qu.:185.8   aritmijam:  4   gubov  :  2   suffix:80       rel :80    
##  Median :270.5   babicam  :  4   jedov  :  2                              
##  Mean   :270.5   bankam   :  4   mečov  :  2                              
##  3rd Qu.:355.2   barabam  :  4   mokov  :  2                              
##  Max.   :440.0   begunkam :  4   žilov  :  2                              
##                  (Other)  :136   (Other):148                              
##    targetFreq       primeFreq        orthOverlap      targetLength  
##  Min.   :  1.00   Min.   :   0.10   Min.   :0.0000   Min.   :5.000  
##  1st Qu.:  8.90   1st Qu.:   6.05   1st Qu.:0.1750   1st Qu.:5.000  
##  Median : 29.55   Median :  24.60   Median :0.3400   Median :6.000  
##  Mean   : 70.08   Mean   :  73.68   Mean   :0.3624   Mean   :6.325  
##  3rd Qu.: 97.92   3rd Qu.:  56.80   3rd Qu.:0.5700   3rd Qu.:7.000  
##  Max.   :434.50   Max.   :1141.50   Max.   :0.7000   Max.   :9.000  
##                                                                     
##   PrimeLength    targetSuffixLength primeSuffixLength
##  Min.   :5.000   Min.   :2          Min.   :2        
##  1st Qu.:5.000   1st Qu.:2          1st Qu.:2        
##  Median :6.000   Median :2          Median :2        
##  Mean   :6.331   Mean   :2          Mean   :2        
##  3rd Qu.:7.000   3rd Qu.:2          3rd Qu.:2        
##  Max.   :9.000   Max.   :2          Max.   :2        
## </code></pre>
<pre class="r"><code>#create variables
stim &lt;- mutate(stim,
  condition =
    ifelse(stim$primingMorpheme == &#39;suffix&#39; 
           &amp; stim$relatedness == &#39;rel&#39;, &quot;suffix_priming&quot;,
           ifelse(stim$primingMorpheme == &#39;suffix&#39;
                  &amp; stim$relatedness == &#39;cntr&#39;, &quot;suffix_control&quot;,
                  ifelse(stim$primingMorpheme == &#39;stem&#39;
                         &amp; stim$relatedness == &#39;rel&#39;, &quot;stem_priming&quot;,
                         ifelse(stim$primingMorpheme == &#39;stem&#39;
                                &amp; stim$relatedness == &#39;cntr&#39;, &quot;stem_control&quot;,
                                &quot;NULL&quot;)))))
stim$condition &lt;- factor(stim$condition);
stim$primeFreq &lt;- as.double(stim$primeFreq);
stim$primeStemLength &lt;- stim$PrimeLength-stim$primeSuffixLength;
stim$targetStemLength &lt;- stim$targetLength-stim$targetSuffixLength;</code></pre>
<pre class="r"><code>#descriptive stats
aggregate(targetStemLength ~ condition, FUN=mean, data=stim);</code></pre>
<pre><code>##        condition targetStemLength
## 1   stem_control            4.325
## 2   stem_priming            4.325
## 3 suffix_control            4.325
## 4 suffix_priming            4.325</code></pre>
<pre class="r"><code>aggregate(targetStemLength~ condition, FUN=sd, data = stim);</code></pre>
<pre><code>##        condition targetStemLength
## 1   stem_control         1.118321
## 2   stem_priming         1.118321
## 3 suffix_control         1.118321
## 4 suffix_priming         1.118321</code></pre>
<pre class="r"><code>aggregate(primeStemLength ~ condition, FUN=mean, data=stim);</code></pre>
<pre><code>##        condition primeStemLength
## 1   stem_control           4.325
## 2   stem_priming           4.325
## 3 suffix_control           4.350
## 4 suffix_priming           4.325</code></pre>
<pre class="r"><code>aggregate(primeStemLength~ condition, FUN=sd, data = stim);</code></pre>
<pre><code>##        condition primeStemLength
## 1   stem_control        1.118321
## 2   stem_priming        1.118321
## 3 suffix_control        1.098951
## 4 suffix_priming        1.118321</code></pre>
<pre class="r"><code>aggregate(targetSuffixLength ~ condition, FUN=mean, data=stim);</code></pre>
<pre><code>##        condition targetSuffixLength
## 1   stem_control                  2
## 2   stem_priming                  2
## 3 suffix_control                  2
## 4 suffix_priming                  2</code></pre>
<pre class="r"><code>aggregate(targetSuffixLength~ condition, FUN=sd, data = stim);</code></pre>
<pre><code>##        condition targetSuffixLength
## 1   stem_control                  0
## 2   stem_priming                  0
## 3 suffix_control                  0
## 4 suffix_priming                  0</code></pre>
<pre class="r"><code>aggregate(primeSuffixLength ~ condition, FUN=mean, data=stim);</code></pre>
<pre><code>##        condition primeSuffixLength
## 1   stem_control                 2
## 2   stem_priming                 2
## 3 suffix_control                 2
## 4 suffix_priming                 2</code></pre>
<pre class="r"><code>aggregate(primeSuffixLength~ condition, FUN=sd, data = stim);</code></pre>
<pre><code>##        condition primeSuffixLength
## 1   stem_control                 0
## 2   stem_priming                 0
## 3 suffix_control                 0
## 4 suffix_priming                 0</code></pre>
<pre class="r"><code>aggregate(log10(targetFreq) ~ condition, FUN=mean, data=stim);</code></pre>
<pre><code>##        condition log10(targetFreq)
## 1   stem_control          1.457591
## 2   stem_priming          1.457591
## 3 suffix_control          1.457591
## 4 suffix_priming          1.457591</code></pre>
<pre class="r"><code>aggregate(log10(targetFreq) ~ condition, FUN=sd, data = stim);</code></pre>
<pre><code>##        condition log10(targetFreq)
## 1   stem_control          0.648854
## 2   stem_priming          0.648854
## 3 suffix_control          0.648854
## 4 suffix_priming          0.648854</code></pre>
<pre class="r"><code>aggregate(log10(primeFreq) ~ condition, FUN=mean, data=stim);</code></pre>
<pre><code>##        condition log10(primeFreq)
## 1   stem_control        0.9695187
## 2   stem_priming        1.4575912
## 3 suffix_control        1.2968365
## 4 suffix_priming        1.2968365</code></pre>
<pre class="r"><code>aggregate(log10(primeFreq) ~ condition, FUN=sd, data = stim);</code></pre>
<pre><code>##        condition log10(primeFreq)
## 1   stem_control        0.8196274
## 2   stem_priming        0.6488540
## 3 suffix_control        0.8059078
## 4 suffix_priming        0.8059078</code></pre>
<pre class="r"><code>aggregate(orthOverlap ~ condition, FUN=mean, data=stim);</code></pre>
<pre><code>##        condition orthOverlap
## 1   stem_control     0.26825
## 2   stem_priming     0.62500
## 3 suffix_control     0.13275
## 4 suffix_priming     0.42375</code></pre>
<pre class="r"><code>aggregate(orthOverlap~ condition, FUN=sd, data = stim);</code></pre>
<pre><code>##        condition orthOverlap
## 1   stem_control  0.12180033
## 2   stem_priming  0.04602118
## 3 suffix_control  0.08972858
## 4 suffix_priming  0.09040330</code></pre>
<pre class="r"><code>#create new environment
data &lt;- read.csv(file = &quot;Data_Experiment1.csv&quot;, head = TRUE, sep = &quot;,&quot;)
summary(data)</code></pre>
<pre><code>##    SubjectID     Rotation      TrialCounter      TrialID            RT        
##  Min.   : 2   Min.   :1.000   Min.   :11.00   Min.   :101.0   Min.   :0.0000  
##  1st Qu.:17   1st Qu.:2.000   1st Qu.:30.75   1st Qu.:195.0   1st Qu.:0.6050  
##  Median :32   Median :2.000   Median :50.50   Median :289.5   Median :0.7285  
##  Mean   :32   Mean   :2.492   Mean   :50.50   Mean   :290.5   Mean   :0.7876  
##  3rd Qu.:47   3rd Qu.:3.000   3rd Qu.:70.25   3rd Qu.:384.5   3rd Qu.:0.9160  
##  Max.   :62   Max.   :4.000   Max.   :90.00   Max.   :480.0   Max.   :1.9360  
##     Response               Condition       Accuracy    
##  Min.   :0.0000   nonword       :2440   Min.   :0.000  
##  1st Qu.:0.0000   stem_control  : 610   1st Qu.:1.000  
##  Median :1.0000   stem_priming  : 610   Median :1.000  
##  Mean   :0.5098   suffix_control: 610   Mean   :0.927  
##  3rd Qu.:1.0000   suffix_priming: 610   3rd Qu.:1.000  
##  Max.   :1.0000                         Max.   :1.000</code></pre>
<pre class="r"><code>#create variables
data &lt;- mutate(data,
  target =
    ifelse(data$TrialID&gt;199 &amp; data$TrialID&lt;299, 
           (data$TrialID&gt;199 &amp; data$TrialID&lt;299)-100,
           ifelse(data$TrialID&gt;299 &amp; data$TrialID&lt;399, 
                  (data$TrialID&gt;299 &amp; data$TrialID&lt;399)-200,
                  ifelse(data$TrialID&gt;399 &amp; data$TrialID&lt;499, 
                         (data$TrialID&gt;399 &amp; data$TrialID&lt;499)-300,
                         data$TrialID-100))));

data$target &lt;- factor(data$target);
data$SubjectID &lt;- factor(data$SubjectID);


data &lt;- mutate(data,
  cond =
    ifelse(data$Condition == &#39;suffix_priming&#39;, 
           &#39;suffix&#39;,
           ifelse(data$Condition == &#39;suffix_control&#39;, 
                  &#39;suffix&#39;,
                  ifelse(data$Condition == &#39;nonword&#39;, 
                         NA,
                         ifelse(data$Condition == &#39;stem_control&#39;,
                                &#39;stem&#39;,
                                &#39;stem&#39;)))))

data &lt;- mutate(data,
  relation =
    ifelse(data$Condition == &#39;suffix_priming&#39;, 
           &#39;prime&#39;,
           ifelse(data$Condition == &#39;suffix_control&#39;, 
                  &#39;control&#39;,
                  ifelse(data$Condition == &#39;nonword&#39;, 
                         NA,
                         ifelse(data$Condition == &#39;stem_control&#39;,
                                &#39;control&#39;,
                                &#39;prime&#39;)))));

# convert the new variables to factors
data$relation &lt;- factor(data$relation); 
data$cond &lt;- factor(data$cond);

data &lt;- mutate(data,
  lexicality =
    ifelse(data$Condition == &#39;nonword&#39;, 
           &#39;nonword&#39;,
           &#39;word&#39;));

data$lexicality = factor(data$lexicality)</code></pre>
<p>So far, everything is exactly what I coded previously (only with different environment name).</p>
<pre class="r"><code>#checking for outliers again
source(&quot;diagf.R&quot;);
diagnostics.f(data$RT, data$Accuracy, data$SubjectID, data$target, data$lexicality , &quot;OutliersCheck&quot;);
hist(data$RT[data$RT&lt;.500 &amp; data$Accuracy==1], breaks=seq(0,.500,.050));</code></pre>
<p><img src="lme4_files/figure-html/oriscript6-1.png" width="672" /></p>
<pre class="r"><code>hist(data$RT[data$RT&gt;1.3 &amp; data$Accuracy==1], breaks=seq(1.3,2,.05))</code></pre>
<p><img src="lme4_files/figure-html/oriscript6-2.png" width="672" /></p>
<div class="figure">
<img src="OutliersCheck.jpg" alt="Same output for outliers check." />
<p class="caption">Same output for outliers check.</p>
</div>
<p>Next, is cleaning up the data. One step that I did differently, or at least in different sequence than the researcher. I, for one thing, did not create two subset, but one.</p>
<pre class="r"><code>#clean data
dataAcc &lt;- subset(data, Condition != &#39;nonword&#39; &amp; SubjectID != &#39;13&#39; &amp; target != &#39;39&#39; &amp; RT&gt;0);
summary(dataAcc);</code></pre>
<pre><code>##    SubjectID       Rotation      TrialCounter      TrialID     
##  2      :  40   Min.   :1.000   Min.   :11.00   Min.   :101.0  
##  3      :  40   1st Qu.:1.000   1st Qu.:29.00   1st Qu.:201.0  
##  6      :  40   Median :2.000   Median :49.00   Median :301.0  
##  7      :  40   Mean   :2.463   Mean   :49.76   Mean   :271.5  
##  9      :  40   3rd Qu.:3.000   3rd Qu.:70.00   3rd Qu.:401.0  
##  10     :  40   Max.   :4.000   Max.   :90.00   Max.   :440.0  
##  (Other):2140                                                  
##        RT            Response               Condition      Accuracy     
##  Min.   :0.2870   Min.   :0.0000   nonword       :  0   Min.   :0.0000  
##  1st Qu.:0.5730   1st Qu.:1.0000   stem_control  :599   1st Qu.:1.0000  
##  Median :0.6740   Median :1.0000   stem_priming  :600   Median :1.0000  
##  Mean   :0.7297   Mean   :0.9403   suffix_control:599   Mean   :0.9403  
##  3rd Qu.:0.8280   3rd Qu.:1.0000   suffix_priming:582   3rd Qu.:1.0000  
##  Max.   :1.8980   Max.   :1.0000                        Max.   :1.0000  
##                                                                         
##      target        cond         relation      lexicality  
##  -199   :600   stem  :1199   control:1198   nonword:   0  
##  -299   :599   suffix:1181   prime  :1182   word   :2380  
##  -99    :599                                              
##  8      : 16                                              
##  12     : 16                                              
##  16     : 16                                              
##  (Other):534</code></pre>
<pre class="r"><code>dataRt &lt;- subset(dataAcc, Accuracy == 1); 
summary(dataRt);</code></pre>
<pre><code>##    SubjectID       Rotation      TrialCounter      TrialID     
##  3      :  40   Min.   :1.000   Min.   :11.00   Min.   :101.0  
##  29     :  40   1st Qu.:1.000   1st Qu.:29.00   1st Qu.:202.0  
##  33     :  40   Median :2.000   Median :49.00   Median :302.0  
##  60     :  40   Mean   :2.463   Mean   :49.84   Mean   :271.8  
##  62     :  40   3rd Qu.:3.000   3rd Qu.:70.00   3rd Qu.:401.0  
##  4      :  39   Max.   :4.000   Max.   :90.00   Max.   :440.0  
##  (Other):1999                                                  
##        RT            Response          Condition      Accuracy     target   
##  Min.   :0.3000   Min.   :1   nonword       :  0   Min.   :1   -199   :569  
##  1st Qu.:0.5720   1st Qu.:1   stem_control  :565   1st Qu.:1   -299   :565  
##  Median :0.6690   Median :1   stem_priming  :569   Median :1   -99    :560  
##  Mean   :0.7198   Mean   :1   suffix_control:560   Mean   :1   8      : 16  
##  3rd Qu.:0.8160   3rd Qu.:1   suffix_priming:544   3rd Qu.:1   20     : 16  
##  Max.   :1.8980   Max.   :1                        Max.   :1   32     : 16  
##                                                                (Other):496  
##      cond         relation      lexicality  
##  stem  :1134   control:1125   nonword:   0  
##  suffix:1104   prime  :1113   word   :2238  
##                                             
##                                             
##                                             
##                                             
## </code></pre>
<pre class="r"><code>#convert s to ms on the RT
dataRt$RTms &lt;- 1000*dataRt$RT;

#descriptive stats
aggregate(RTms ~ Condition, FUN=mean, data=dataRt); </code></pre>
<pre><code>##        Condition     RTms
## 1   stem_control 715.8743
## 2   stem_priming 694.6573
## 3 suffix_control 744.9786
## 4 suffix_priming 724.3713</code></pre>
<pre class="r"><code>aggregate(RTms ~ Condition, FUN=sd, data = dataRt);</code></pre>
<pre><code>##        Condition     RTms
## 1   stem_control 214.7987
## 2   stem_priming 213.2498
## 3 suffix_control 236.0622
## 4 suffix_priming 217.3826</code></pre>
<pre class="r"><code>#checking medians too, RTs are quite long:
aggregate(RTms ~ Condition, FUN=median, data=dataRt); </code></pre>
<pre><code>##        Condition  RTms
## 1   stem_control 665.0
## 2   stem_priming 645.0
## 3 suffix_control 698.5
## 4 suffix_priming 672.0</code></pre>
<pre class="r"><code>aggregate(RTms ~ Condition, FUN=IQR, data=dataRt); </code></pre>
<pre><code>##        Condition   RTms
## 1   stem_control 231.00
## 2   stem_priming 217.00
## 3 suffix_control 267.25
## 4 suffix_priming 253.75</code></pre>
<pre class="r"><code>#descriptive stats
aggregate(Accuracy ~ Condition, FUN=mean, data=dataAcc);</code></pre>
<pre><code>##        Condition  Accuracy
## 1   stem_control 0.9432387
## 2   stem_priming 0.9483333
## 3 suffix_control 0.9348915
## 4 suffix_priming 0.9347079</code></pre>
<pre class="r"><code>aggregate(Accuracy ~ Condition, FUN=sd, data=dataAcc);</code></pre>
<pre><code>##        Condition  Accuracy
## 1   stem_control 0.2315793
## 2   stem_priming 0.2215379
## 3 suffix_control 0.2469234
## 4 suffix_priming 0.2472531</code></pre>
<p>Similar descriptive statistics for the experimental data.</p>
<p>Now to run the lme model. The researcher used <code>car</code> package to perform ANOVA, which was loaded in the beginning. Also, as I’ve mentioned previously, the researcher used <code>relevel</code> to set a reference level prior to the analysis at this stage.</p>
<pre class="r"><code>#merge data and stimuli properties 
dataRt &lt;- merge(dataRt, stim, by.x=&#39;TrialID&#39;, by.y=&#39;TrialID&#39;);

# run the model
dataRt$relation &lt;- relevel(dataRt$relation, &#39;control&#39;);
dataRt$cond &lt;- relevel(dataRt$cond, &#39;stem&#39;);
modelRT &lt;- lmer(-1000/RTms ~  relation * cond + primeFreq + (1| SubjectID) + (1| target.x ), data=dataRt,  REML=T);
summary(modelRT);</code></pre>
<pre><code>## Linear mixed model fit by REML. t-tests use Satterthwaite&#39;s method [
## lmerModLmerTest]
## Formula: -1000/RTms ~ relation * cond + primeFreq + (1 | SubjectID) +  
##     (1 | target.x)
##    Data: dataRt
## 
## REML criterion at convergence: 1007.4
## 
## Scaled residuals: 
##     Min      1Q  Median      3Q     Max 
## -4.5428 -0.6286 -0.0503  0.6284  4.1225 
## 
## Random effects:
##  Groups    Name        Variance Std.Dev.
##  SubjectID (Intercept) 0.074130 0.27227 
##  target.x  (Intercept) 0.007716 0.08784 
##  Residual              0.080927 0.28448 
## Number of obs: 2238, groups:  SubjectID, 60; target.x, 42
## 
## Fixed effects:
##                            Estimate Std. Error         df t value Pr(&gt;|t|)    
## (Intercept)              -1.508e+00  9.539e-02  1.658e+01 -15.808 1.99e-11 ***
## relationprime            -5.713e-02  1.254e-01  1.245e+01  -0.456  0.65646    
## condsuffix                4.350e-02  1.254e-01  1.245e+01   0.347  0.73448    
## primeFreq                 1.079e-04  3.907e-05  6.029e+02   2.762  0.00593 ** 
## relationprime:condsuffix  2.724e-02  1.547e-01  1.260e+01   0.176  0.86302    
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## Correlation of Fixed Effects:
##             (Intr) rltnpr cndsff prmFrq
## relationprm -0.657                     
## condsuffix  -0.657  0.500              
## primeFreq   -0.018 -0.008 -0.014       
## rltnprm:cnd  0.533 -0.811 -0.811  0.007</code></pre>
<pre class="r"><code>Anova(modelRT, type=3, test.statistic=&#39;F&#39;)</code></pre>
<pre><code>## Analysis of Deviance Table (Type III Wald F tests with Kenward-Roger df)
## 
## Response: -1000/RTms
##                      F Df Df.res   Pr(&gt;F)    
## (Intercept)   249.8981  1  16.53  2.1e-11 ***
## relation        0.2077  1  12.40 0.656489    
## cond            0.1203  1  12.41 0.734501    
## primeFreq       7.4965  1 601.29 0.006365 ** 
## relation:cond   0.0310  1  12.56 0.863025    
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</code></pre>
<p>The next script, the researcher analysed the differences from the outputs, if outliers were excluded from the analysis. However, I decided to not run the remaining script. Prior to this trial, I have copied the exact script with the exact format into a new RSTudio window. I ran the script and results were exactly right and were the values reported on the paper. As the previous <code>Anova</code> analysis did not yield the same results, I decided to terminate this trial.</p>
<pre class="r"><code># run the model without the outliers terminated
modelRTb &lt;- lmer(-1000/RTms ~  relation * cond+ primeFreq  + (1| SubjectID) + (1| target.x ), data=subset(dataRt, abs(scale(resid(modelRT)))&lt;2.5),  REML=T);
summary(modelRTb)</code></pre>
</div>
<div id="trial-6" class="section level5">
<h5>Trial 6</h5>
<p>At this point, I am lost and frustrated as I do not know what have I done wrong. One major difference between my script and the original script is the way in which new variables were created. In my script, I have used <code>mutate</code> and <code>ifelse</code> functions, whereas the original script created new variables in a different way. I do not know if this makes any difference and whether it will affect the analysis, but I couldn’t think of anything else that I did differently to the original code in <strong>Trial 5</strong>.</p>
<p>Hence, being really lost, in this trial, I am very sad (<em>really sad</em>) to say that I will use the <em>exact copy</em> of the original script to conduct the analysis.</p>
<pre class="r"><code>#import libraries
library(lmerTest); #for linear mixed modeling
library(effects); #for plotting the output of the mixed models and compute effect size</code></pre>
<pre><code>## lattice theme set by effectsTheme()
## See ?effectsTheme for details.</code></pre>
<pre class="r"><code>library(ggplot2); #for generic plotting
library(dplyr);  #for plotting the distributions per subject
library(car); #for running Anova
invF &lt;- function(x) -1000/x; #for back transforming effects to ms

#import stimuli features file
stim1 &lt;- read.csv(file = &quot;StimuliProperties_Experiment1.csv&quot;, head = TRUE, sep = &quot;,&quot;)
summary(stim1);
#create variable condition
stim1$condition &lt;- &#39;condition&#39;;
stim1$condition[stim1$primingMorpheme == &#39;suffix&#39; &amp; stim1$relatedness == &#39;rel&#39;] &lt;- &#39;suffix_priming&#39;
stim1$condition[stim1$primingMorpheme == &#39;suffix&#39; &amp; stim1$relatedness == &#39;cntr&#39;] &lt;- &#39;suffix_control&#39;
stim1$condition[stim1$primingMorpheme == &#39;stem&#39; &amp; stim1$relatedness == &#39;rel&#39;] &lt;- &#39;stem_priming&#39;
stim1$condition[stim1$primingMorpheme == &#39;stem&#39; &amp; stim1$relatedness == &#39;cntr&#39;] &lt;- &#39;stem_control&#39;
stim1$condition &lt;- factor(stim1$condition);
stim1$primeFreq &lt;-as.double(stim1$primeFreq);
stim1$primeStemLength &lt;- stim1$PrimeLength-stim1$primeSuffixLength;
stim1$targetStemLength &lt;- stim1$targetLength-stim1$targetSuffixLength;</code></pre>
<pre class="r"><code>#descriptive stats
aggregate(targetStemLength ~ condition, FUN=mean, data=stim1);</code></pre>
<pre><code>##        condition targetStemLength
## 1   stem_control            4.325
## 2   stem_priming            4.325
## 3 suffix_control            4.325
## 4 suffix_priming            4.325</code></pre>
<pre class="r"><code>aggregate(targetStemLength~ condition, FUN=sd, data = stim1);</code></pre>
<pre><code>##        condition targetStemLength
## 1   stem_control         1.118321
## 2   stem_priming         1.118321
## 3 suffix_control         1.118321
## 4 suffix_priming         1.118321</code></pre>
<pre class="r"><code>aggregate(primeStemLength ~ condition, FUN=mean, data=stim1);</code></pre>
<pre><code>##        condition primeStemLength
## 1   stem_control           4.325
## 2   stem_priming           4.325
## 3 suffix_control           4.350
## 4 suffix_priming           4.325</code></pre>
<pre class="r"><code>aggregate(primeStemLength~ condition, FUN=sd, data = stim1);</code></pre>
<pre><code>##        condition primeStemLength
## 1   stem_control        1.118321
## 2   stem_priming        1.118321
## 3 suffix_control        1.098951
## 4 suffix_priming        1.118321</code></pre>
<pre class="r"><code>aggregate(targetSuffixLength ~ condition, FUN=mean, data=stim1);</code></pre>
<pre><code>##        condition targetSuffixLength
## 1   stem_control                  2
## 2   stem_priming                  2
## 3 suffix_control                  2
## 4 suffix_priming                  2</code></pre>
<pre class="r"><code>aggregate(targetSuffixLength~ condition, FUN=sd, data = stim1);</code></pre>
<pre><code>##        condition targetSuffixLength
## 1   stem_control                  0
## 2   stem_priming                  0
## 3 suffix_control                  0
## 4 suffix_priming                  0</code></pre>
<pre class="r"><code>aggregate(primeSuffixLength ~ condition, FUN=mean, data=stim1);</code></pre>
<pre><code>##        condition primeSuffixLength
## 1   stem_control                 2
## 2   stem_priming                 2
## 3 suffix_control                 2
## 4 suffix_priming                 2</code></pre>
<pre class="r"><code>aggregate(primeSuffixLength~ condition, FUN=sd, data = stim1);</code></pre>
<pre><code>##        condition primeSuffixLength
## 1   stem_control                 0
## 2   stem_priming                 0
## 3 suffix_control                 0
## 4 suffix_priming                 0</code></pre>
<pre class="r"><code>aggregate(log10(targetFreq) ~ condition, FUN=mean, data=stim1);</code></pre>
<pre><code>##        condition log10(targetFreq)
## 1   stem_control          1.457591
## 2   stem_priming          1.457591
## 3 suffix_control          1.457591
## 4 suffix_priming          1.457591</code></pre>
<pre class="r"><code>aggregate(log10(targetFreq) ~ condition, FUN=sd, data = stim1);</code></pre>
<pre><code>##        condition log10(targetFreq)
## 1   stem_control          0.648854
## 2   stem_priming          0.648854
## 3 suffix_control          0.648854
## 4 suffix_priming          0.648854</code></pre>
<pre class="r"><code>aggregate(log10(primeFreq) ~ condition, FUN=mean, data=stim1);</code></pre>
<pre><code>##        condition log10(primeFreq)
## 1   stem_control        0.9695187
## 2   stem_priming        1.4575912
## 3 suffix_control        1.2968365
## 4 suffix_priming        1.2968365</code></pre>
<pre class="r"><code>aggregate(log10(primeFreq) ~ condition, FUN=sd, data = stim1);</code></pre>
<pre><code>##        condition log10(primeFreq)
## 1   stem_control        0.8196274
## 2   stem_priming        0.6488540
## 3 suffix_control        0.8059078
## 4 suffix_priming        0.8059078</code></pre>
<pre class="r"><code>aggregate(orthOverlap ~ condition, FUN=mean, data=stim1);</code></pre>
<pre><code>##        condition orthOverlap
## 1   stem_control     0.26825
## 2   stem_priming     0.62500
## 3 suffix_control     0.13275
## 4 suffix_priming     0.42375</code></pre>
<pre class="r"><code>aggregate(orthOverlap~ condition, FUN=sd, data = stim1)</code></pre>
<pre><code>##        condition orthOverlap
## 1   stem_control  0.12180033
## 2   stem_priming  0.04602118
## 3 suffix_control  0.08972858
## 4 suffix_priming  0.09040330</code></pre>
<p>Descriptive statistics for the stimuli looks okay.</p>
<pre class="r"><code>#read the data file
read.csv(file = &quot;Data_Experiment1.csv&quot;, head = TRUE, sep = &quot;,&quot;) -&gt; data1;
summary(data1);
#create a variable for target word
data1$target &lt;- data1$TrialID-100;
data1$target[data1$TrialID&gt;199 &amp; data1$TrialID&lt;299] &lt;- data1$target[data1$TrialID&gt;199 &amp; data1$TrialID&lt;299]-100;
data1$target[data1$TrialID&gt;299 &amp; data1$TrialID&lt;399] &lt;- data1$target[data1$TrialID&gt;299 &amp; data1$TrialID&lt;399]-200;
data1$target[data1$TrialID&gt;399 &amp; data1$TrialID&lt;499] &lt;- data1$target[data1$TrialID&gt;399 &amp; data1$TrialID&lt;499]-300;

#factor sbj and items
data1$target &lt;- factor(data1$target);
data1$SubjectID &lt;- factor(data1$SubjectID);

#create new variables &quot;cond&quot;: suffix/stem and &quot;relation&quot;: control/prime
data1$cond &lt;- &#39;stem&#39;;
data1$cond[data1$Condition == &#39;suffix_priming&#39;] &lt;- &#39;suffix&#39;;
data1$cond[data1$Condition == &#39;suffix_control&#39;] &lt;- &#39;suffix&#39;;
data1$cond[data1$Condition == &#39;nonword&#39;] &lt;- NA;
data1$relation&lt;- &#39;control&#39;;
data1$relation[data1$Condition == &#39;suffix_priming&#39;] &lt;- &#39;prime&#39;;
data1$relation[data1$Condition == &#39;stem_priming&#39;] &lt;- &#39;prime&#39;;
data1$relation[data1$Condition == &#39;nonword&#39;] &lt;- NA;
# convert the new variables to factors
data1$relation &lt;- factor(data1$relation); 
data1$cond &lt;- factor(data1$cond); </code></pre>
<pre class="r"><code>## run the diagnostics, to check for outliers in subjects and items based on RT and accuracy
data1$lexicality = &quot;word&quot;
data1$lexicality[data1$Condition == &#39;nonword&#39;] &lt;- &#39;nonword&#39;
data1$lexicality = factor(data1$lexicality)

source(&quot;diagf.R&quot;);
diagnostics.f(data1$RT, data1$Accuracy, data1$SubjectID, data1$target, data1$lexicality , &quot;OutliersCheck2&quot;);
#we will omit subject 13, and target word 39 from further analysis
hist(data1$RT[data1$RT&lt;.500 &amp; data1$Accuracy==1], breaks=seq(0,.500,.050)); </code></pre>
<p><img src="lme4_files/figure-html/superoriginal4-1.png" width="672" /></p>
<pre class="r"><code>hist(data1$RT[data1$RT&gt;1.3 &amp; data1$Accuracy==1], breaks=seq(1.3,2,.05))</code></pre>
<p><img src="lme4_files/figure-html/superoriginal4-2.png" width="672" /></p>
<div class="figure">
<img src="OutliersCheck2.jpg" alt="Outliers check looks okay too." />
<p class="caption">Outliers check looks okay too.</p>
</div>
<pre class="r"><code>#clean data to keep only acual words, omit the wrong trials and trials without response
data1Acc &lt;- subset(data1, Condition != &#39;nonword&#39; &amp; SubjectID != &#39;13&#39; &amp; target != &#39;39&#39; &amp; RT&gt;0);
summary(data1Acc);
data1Rt &lt;- subset(data1Acc, Accuracy == 1); 
summary(data1Rt);

#convert s to ms on the RT
data1Rt$RTms &lt;- 1000*data1Rt$RT;</code></pre>
<pre class="r"><code>#descriptive stats
aggregate(RTms ~ Condition, FUN=mean, data=data1Rt); </code></pre>
<pre><code>##        Condition     RTms
## 1   stem_control 709.8366
## 2   stem_priming 687.9445
## 3 suffix_control 738.1724
## 4 suffix_priming 724.3713</code></pre>
<pre class="r"><code>aggregate(RTms ~ Condition, FUN=sd, data = data1Rt);</code></pre>
<pre><code>##        Condition     RTms
## 1   stem_control 209.8060
## 2   stem_priming 205.7570
## 3 suffix_control 227.8008
## 4 suffix_priming 217.3826</code></pre>
<pre class="r"><code>#checking medians too, RTs are quite long:
aggregate(RTms ~ Condition, FUN=median, data=data1Rt); </code></pre>
<pre><code>##        Condition RTms
## 1   stem_control  662
## 2   stem_priming  639
## 3 suffix_control  690
## 4 suffix_priming  672</code></pre>
<pre class="r"><code>aggregate(RTms ~ Condition, FUN=IQR, data=data1Rt); </code></pre>
<pre><code>##        Condition   RTms
## 1   stem_control 229.00
## 2   stem_priming 211.50
## 3 suffix_control 265.50
## 4 suffix_priming 253.75</code></pre>
<pre class="r"><code>#descriptive stats
aggregate(Accuracy ~ Condition, FUN=mean, data=data1Acc);</code></pre>
<pre><code>##        Condition  Accuracy
## 1   stem_control 0.9537671
## 2   stem_priming 0.9555556
## 3 suffix_control 0.9418803
## 4 suffix_priming 0.9347079</code></pre>
<pre class="r"><code>aggregate(Accuracy ~ Condition, FUN=sd, data=data1Acc)</code></pre>
<pre><code>##        Condition  Accuracy
## 1   stem_control 0.2101691
## 2   stem_priming 0.2062568
## 3 suffix_control 0.2341698
## 4 suffix_priming 0.2472531</code></pre>
<p>So far so good.</p>
<pre class="r"><code>#merge data and stimuli properties 
data1Rt &lt;- merge(data1Rt, stim1, by.x=&#39;TrialID&#39;, by.y=&#39;TrialID&#39;);

# run the model
data1Rt$relation &lt;- relevel(data1Rt$relation, &#39;control&#39;);
data1Rt$cond &lt;- relevel(data1Rt$cond, &#39;stem&#39;);
model1RT &lt;- lmer(-1000/RTms ~  relation * cond + primeFreq + (1| SubjectID) + (1| target.x ), data=data1Rt,  REML=T);
summary(model1RT);</code></pre>
<pre><code>## Linear mixed model fit by REML. t-tests use Satterthwaite&#39;s method [
## lmerModLmerTest]
## Formula: -1000/RTms ~ relation * cond + primeFreq + (1 | SubjectID) +  
##     (1 | target.x)
##    Data: data1Rt
## 
## REML criterion at convergence: 768.9
## 
## Scaled residuals: 
##     Min      1Q  Median      3Q     Max 
## -5.2907 -0.6166 -0.0320  0.6168  4.3787 
## 
## Random effects:
##  Groups    Name        Variance Std.Dev.
##  SubjectID (Intercept) 0.07453  0.27300 
##  target.x  (Intercept) 0.00971  0.09854 
##  Residual              0.07104  0.26654 
## Number of obs: 2211, groups:  SubjectID, 60; target.x, 39
## 
## Fixed effects:
##                            Estimate Std. Error         df t value Pr(&gt;|t|)    
## (Intercept)              -1.505e+00  4.029e-02  8.867e+01 -37.359  &lt; 2e-16 ***
## relationprime            -5.592e-02  1.602e-02  2.110e+03  -3.492  0.00049 ***
## condsuffix                4.887e-02  1.616e-02  2.113e+03   3.025  0.00252 ** 
## primeFreq                -3.179e-05  4.094e-05  1.731e+03  -0.776  0.43759    
## relationprime:condsuffix  3.293e-02  2.276e-02  2.109e+03   1.447  0.14800    
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## Correlation of Fixed Effects:
##             (Intr) rltnpr cndsff prmFrq
## relationprm -0.195                     
## condsuffix  -0.191  0.502              
## primeFreq   -0.048 -0.066 -0.114       
## rltnprm:cnd  0.137 -0.705 -0.707  0.055</code></pre>
<pre class="r"><code>Anova(model1RT, type=3, test.statistic=&#39;F&#39;)</code></pre>
<pre><code>## Analysis of Deviance Table (Type III Wald F tests with Kenward-Roger df)
## 
## Response: -1000/RTms
##                       F Df Df.res    Pr(&gt;F)    
## (Intercept)   1395.6536  1   88.9 &lt; 2.2e-16 ***
## relation        12.1919  1 2111.2 0.0004898 ***
## cond             9.1498  1 2114.3 0.0025175 ** 
## primeFreq        0.5981  1 1745.2 0.4394015    
## relation:cond    2.0941  1 2110.9 0.1480127    
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</code></pre>
<p>Not sure if I should be happy but this yielded results that were reported on the paper (see below). Both relation and condition effects are significant with p-values &lt; 0.001 and = 0.002 respectively. F values also match those reported. The interaction is also not significant with p-values of 0.15, as reported in the paper.</p>
<p>When reference level was set to suffix, results were also exactly what was reported.</p>
<pre class="r"><code>###set reference level to suffix
data1Rt$cond &lt;- relevel(data1Rt$cond, &#39;suffix&#39;);
model1RTsuf &lt;- lmer(-1000/RTms ~  relation * cond + primeFreq + (1| SubjectID) + (1| target.x ), data=data1Rt,  REML=T);
summary(model1RTsuf);</code></pre>
<pre><code>## Linear mixed model fit by REML. t-tests use Satterthwaite&#39;s method [
## lmerModLmerTest]
## Formula: -1000/RTms ~ relation * cond + primeFreq + (1 | SubjectID) +  
##     (1 | target.x)
##    Data: data1Rt
## 
## REML criterion at convergence: 768.9
## 
## Scaled residuals: 
##     Min      1Q  Median      3Q     Max 
## -5.2907 -0.6166 -0.0320  0.6168  4.3787 
## 
## Random effects:
##  Groups    Name        Variance Std.Dev.
##  SubjectID (Intercept) 0.07453  0.27300 
##  target.x  (Intercept) 0.00971  0.09854 
##  Residual              0.07104  0.26654 
## Number of obs: 2211, groups:  SubjectID, 60; target.x, 39
## 
## Fixed effects:
##                          Estimate Std. Error         df t value Pr(&gt;|t|)    
## (Intercept)            -1.456e+00  4.044e-02  8.996e+01 -36.012  &lt; 2e-16 ***
## relationprime          -2.299e-02  1.614e-02  2.109e+03  -1.424  0.15466    
## condstem               -4.887e-02  1.616e-02  2.113e+03  -3.025  0.00252 ** 
## primeFreq              -3.179e-05  4.094e-05  1.731e+03  -0.776  0.43759    
## relationprime:condstem -3.293e-02  2.276e-02  2.109e+03  -1.447  0.14800    
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## Correlation of Fixed Effects:
##             (Intr) rltnpr cndstm prmFrq
## relationprm -0.199                     
## condstem    -0.209  0.498              
## primeFreq   -0.093  0.012  0.114       
## rltnprm:cnd  0.146 -0.710 -0.707 -0.055</code></pre>
<pre class="r"><code>Anova(model1RTsuf, type=3, test.statistic=&#39;F&#39;)</code></pre>
<pre><code>## Analysis of Deviance Table (Type III Wald F tests with Kenward-Roger df)
## 
## Response: -1000/RTms
##                       F Df  Df.res    Pr(&gt;F)    
## (Intercept)   1296.7401  1   90.19 &lt; 2.2e-16 ***
## relation         2.0270  1 2110.12  0.154669    
## cond             9.1498  1 2114.34  0.002517 ** 
## primeFreq        0.5981  1 1745.23  0.439402    
## relation:cond    2.0941  1 2110.89  0.148013    
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</code></pre>
<p>As mentioned in the paper, when reference level was set to suffix, the relation effect becomes not significant. To read my full discussion on this analysis, please refer to the home page <a href="file.html">here</a>.</p>
</div>
</div>
</div>
<div id="remarks-on-my-attempt-with-lme4" class="section level3">
<h3>Remarks on my attempt with lme4</h3>
<p>After several days and 6 trials with analysing a data with <code>lme4</code>, I realised that this is a very complicated package to use and understand. My mind is tired, confused, frustrated that I had to end up using the original script to attain the results. There is so much for me to learn with <code>lme4</code>, and I believe that starting from the bottom, the very beginning in understanding the concept of linear mixed model would be the best choice.</p>
<p>Now moving on to <a href="ggplot.html">plotting</a> the results to tables and graphs.</p>
<style>

h1.title {
  font-size: 32px;
  color: slategrey;
}

h3 {
  font-size: 25px;
  color: grey;
}

h4 {
  font-size: 20px;
  color: darkgrey;
}

p {color: royalblue}

h5 {
    font-size: 15px;
    color: darkslategrey;
}
</style>
</div>




</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open')
  });
});
</script>

<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
